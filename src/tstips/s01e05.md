---
title: S01E05 - Beware, not everything that shines is gold 🏅
summary: A list of awesome intermediate/advanced TS functionalities, often underused by professionals
date: 2020-08-21
author: Marcelo Tokarnia
authorPic: https://res.cloudinary.com/marcelotokarnia/image/upload/c_thumb,g_face:center,r_max,h_150,w_150,f_auto,q_auto/v1590609457/profile/A54I1782_qa84qz.jpg
tags: TS,Typings,Typescript
---

## empty types

- differences between null / undefined / void / never

### undefined vs null

Originally, `null` is intended to be a value explicitly set to `null` while `undefined` is a value that simply was not defined.

For example, let's rewrite [the graphql example](/ts/s01e01#partial-and-required)

```js
type Query1Response = Partial<{
  attr1: string | null
  attr2: string | null
  attr3: string | null
  attr4: string | null
}>

type GraphqlResponse = {
  data: Partial<{
    query1: Query1Response
  }>
}

const callGraphqlApi = async (
  query: string,
  variables?: Record<string, any>
): Promise<GraphqlResponse> => api.graphql({ body: { query, variables } })

const query1 = (await callGraphqlApi(`{query1{attr1,attr2}}`)).data?.query1
```

note that this graphql call is looking for `attr1` and `attr2` in the `query1`, and explicitly not asking for `attr3` and `attr4`.

So it is expected that your `query1.attr3` is `undefined`, because the API will not include that in the response. And remember, that's an allowed type, due to the `Partial` generic wrapping `Query1Response`.

While `query.attr1` could be `null`, meaning that, even if you explicitly asked for that from the `API`, the `API` might not be able to resolve that, there is no such information on the database or whatever source of truth. Could be, example a field referring to the AC brand of a car, but that specific car has no AC, so its brand (the field value) is explicitly set to `null` in the data modelling.

### the void type

The void type is pretty much the opposite of `any`, is meant to be the absence of all types.

Ok, but what does that mean ?

It's pretty much meant to be used in functions that don't return, for example:

```js
const voidFn = (): void => {
  console.log('Void function returns nothing')
}
voidFn()
```

Even though it's also valid to assign `undefined` to it, but seriously, what's the point ? 😅

```js
const why: void = undefined // 👍🏻 no errors, but why would you do that ? 🤔
```

References:

- [void - Typescript Handbook][void-handbook]

### the never type

Never is meant to express something that is `never` reachable, for example, a function with an infinite loop, or a function that always throws (therefore never returns).

```js
function throwAnError(message: string): never {
  throw new Error(message)
}
const infiniteLoop = (): never => {
  while (true) {
    console.log('TS')
  }
}
```

Simple enough, right ? 🟢 🤡

Wrong! 🔴 ✋🏻

The never type is a tricky one, by definition:

"Variables also acquire the type never when narrowed by any type guards that can never be true.", therefore the last, conflicting example mentioned in [Intersections](/ts/s01e03#union-and-intersection)

But it only gets trickier:

"The never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never."

What does that mean in examples?

```js
const x: never = 1 // 💣💥
// 👆🏻 Type '1' is not assignable to type 'never'.ts(2322)
const callApiThatThrows = async (p): never => {...}

const y: number = callApiThatThrows(1) // 👍🏻
```

Even though this would be quite hard to actually happen, since TS has other means to prevent you from creating a function with a return type never that actually returns something, this could happen if you abuse castings or delegate responsibility of such functions to external modules or so

Leading you to maybe assigning anything else to `const y` due to the fact that the function has a return type `never`, therefore accepted by `number`, which is a bit hard to grasp, and, as I said, hard to happen, but well, could also happen as a result of an inappropriate Intersection, as we've seen above.

It's just good to know the rules of the game you are playing, even if you don't need this piece of information everyday. Might be handy to solve some inexplicable bugs

References:

- [never - Typescript Handbook][never-handbook]

## unknown vs any

ref:https://mariusschulz.com/articles/the-unknown-type-in-typescript#:~:text=The%20main%20difference%20between%20unknown,on%20values%20of%20type%20any%20.

## interfaces vs types

- extends vs & (beware of `never` types)

---

<div>
<a href="/ts/s01e00" style="float: right; padding-bottom: 15px">🎉🎉Congrats, you are awesome🎉🎉🎉</a>
<a href="/ts/s01e04" style="float: left; padding-bottom: 15px">👈🏻👈🏻👈🏻 Survival Tricks</a>
</div>
<br/>

<!-- empty types References  -->

[never-handbook]: https://www.typescriptlang.org/docs/handbook/basic-types.html#never
[void-handbook]: https://www.typescriptlang.org/docs/handbook/basic-types.html#void

<!-- unknown vs any References  -->

[unknown-handbook]: https://www.typescriptlang.org/docs/handbook/basic-types.html#unknown
[any-handbook]: https://www.typescriptlang.org/docs/handbook/basic-types.html#any

<!-- interfaces vs types References  -->
