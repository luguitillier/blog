---
title: S01E04 - Some survival tricks
summary: When you are out in the Typescript jungle you will need a few gadgets to survive
date: 2020-08-21
author: Marcelo Tokarnia
authorPic: https://res.cloudinary.com/marcelotokarnia/image/upload/c_thumb,g_face:center,r_max,h_150,w_150,f_auto,q_auto/v1590609457/profile/A54I1782_qa84qz.jpg
tags: TS,Typings,Typescript
---

## Generics

## Companion Object

Companion object is a pattern used by many other typed languages as well, in sum, it's the ability to declare a type and a logic variable with the same name, so the compiler is smart enough to know which (type or logic) to use depending on the context.

It's very common in packages, so the consumer of the package don't need to know if a reference is logic or type, it's both. Let's see an example:

```js
import { Kafka } from 'kafkajs'

const kafkaClient: Kafka = new Kafka(...)
```

of course we wouldn't need to explicitly mention `Kafka` twice, because the compiler is smart enough to make this [inference](/ts/s01e04#annotation-vs-inference).

But the point is, it works! You can refer to Kafka as a type AND as logic. This is how you USE companion objects. But okay, what if I want to declare my own companion object ? Well, there are two ways.

1. Classes, by default they work "as companion objects would"

```js
class Companion {
  public constructor(name: string) {}
}

const bla: Companion = new Companion('1')
```

I'm not going to focus too much on this implementation to be honest because ~~using classes is wrong~~ it's not really my code style, and there is not much new here, I bet most people already seen a class in JS before, even though they are not the most common thing.

2. Companion objects, per say:

You can declare (and export) both a type and a logic piece of code with the same name inside the same module.

And this is the classic example from [Boris Cherny][programming-typescript]

```js
// Currency.ts
type Currency = {
  unit: 'EUR' | 'GBP' | 'JPY' | 'USD',
  value: number,
}

let Currency = {
  DEFAULT: 'USD',
  from(value: number, unit = Currency.DEFAULT): Currency {
    return { unit, value }
  },
}

export { Currency }

// index.ts
import { Currency } from './Currency'

// Use case 1: Used as type
let amountDue: Currency = {
  unit: 'JPY',
  value: 83733.1,
}

// use case 2: Used as factory object
let otherAmountDue = Currency.from(330, 'EUR')

console.log({ amountDue, otherAmountDue })
```

But in my humble opinion, the big feature about companion objects is that you can even use the logic bit in the type declaration, opening up a wide horizon of opportunities ü§Ø, I'll give an example of [how I type my redux actions][companion-redux-actions], this is a long one, utilizing everything we've studied so far, [Generics](/ts/s01e04#interfaces-vs-types), [Overloads](/ts/s01e03#overloads) and [extensions](/ts/s01e03#extends):

```js
export function createAction<T extends string>(type: T): Action<T>
export function createAction<T extends string, P>(type: T, payload: P): ActionWithPayload<T, P>
export function createAction<T extends string, P>(type: T, payload?: P) {
  return payload ? { type, payload } : { type }
}
type FunctionType = (...args: any[]) => any
type ActionCreatorsMapObject = { [actionCreator: string]: FunctionType }
type ActionsUnion<A extends ActionCreatorsMapObject> = ReturnType<A[keyof A]>

export const ActivitiesActions = {
  changeActivityAnimation: (p: { animationPercentage: number, id: string }) =>
    createAction(ActivitiesTypes.ANIMATE_ACTIVITY, p),
}

export type ActivitiesActions = ActionsUnion<typeof ActivitiesActions>
```

This way, the action will always be typed correctly according to the type definition I set for `p` as a parameter, so when using it, the action payload will always have the same type as `p`, or the action will be passed along without payload if `p` is not specified. Isn't that sweet as donuts !? üç©

That's by far the best solution for typing redux actions I've seen so far, [inspired by this article][actions-union-redux]

## annotation vs inference

---

<div>
<a href="/ts/s01e05" style="float: right; padding-bottom: 15px">Hidden Dangers of TS üëâüèªüëâüèªüëâüèª</a>
<a href="/ts/s01e03" style="float: left; padding-bottom: 15px">üëàüèªüëàüèªüëàüèª Function overloads</a>
</div>
<br/>

<!-- Generics References -->

<!-- Companion Object References -->

[programming-typescript]: https://www.goodreads.com/book/show/45362865-programming-typescript
[companion-redux-actions]: https://github.com/marcelotokarnia/strava-maps/blob/ef10711b25ac122829ad348ed2b693c171e38d5b/frontend/src/store/actions/activities.ts
[actions-union-redux]: https://medium.com/@martin_hotell/improved-redux-type-safety-with-typescript-2-8-2c11a8062575

<!-- Annotation vs Inference References -->
